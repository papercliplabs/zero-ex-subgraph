####
# Protocol
####

type Protocol @entity {
    "Hardcoded 0"
    id: Bytes!

    data: ProtocolData!

    # Derived
    accounts: [Account!]! @derivedFrom(field: "_protocol")

    erc20Tokens: [Erc20Token!]! @derivedFrom(field: "_protocol")
    erc20TokenPairs: [Erc20TokenPair!]! @derivedFrom(field: "_protocol")
    erc20Fills: [Erc20Fill!]! @derivedFrom(field: "_protocol")
    erc20FillTypeSummary: [Erc20FillTypeSummary!]! @derivedFrom(field: "_protocol")

    nftCollections: [NftCollection!]! @derivedFrom(field: "_protocol")
    nfts: [Nft!]! @derivedFrom(field: "_protocol")
    nftFills: [NftFill!]! @derivedFrom(field: "_protocol")

    transactions: [Transaction!]! @derivedFrom(field: "_protocol")
}

type ProtocolData @entity {
    "protocol ID + time qualifier"
    id: Bytes!

    erc20FillVolumeUsd: BigDecimal!
    erc20FillCount: BigInt!

    nftFillErc20VolumeUsd: BigDecimal!
    nftFillCount: BigInt!

    uniqueUserCount: BigInt!
}

####
# Account
####

type Account @entity {
    "Address"
    id: Bytes!

    _protocol: Protocol!

    "Account address"
    address: Bytes!

    data: AccountData!

    # Derived
    erc20SourceFills: [Erc20Fill!]! @derivedFrom(field: "source")
    erc20FillerFills: [Erc20Fill!]! @derivedFrom(field: "filler")
    erc20DestinationFills: [Erc20Fill!]! @derivedFrom(field: "destination")

    nftMakerFills: [NftFill!]! @derivedFrom(field: "maker")
    nftTakerFills: [NftFill!]! @derivedFrom(field: "taker")
}

type AccountData @entity {
    id: Bytes!

    erc20FillSourceVolumeUsd: BigDecimal!
    erc20FillFillerVolumeUsd: BigDecimal!
    erc20FillDestinationVolumeUsd: BigDecimal!

    erc20FillSourceCount: BigInt!
    erc20FillFillerCount: BigInt!
    erc20FillDestinationCount: BigInt!
}

type _ActiveUser @entity {
    "Address + usecase specific metadata, this is just a helper for tracking overall usage"
    id: Bytes!
}

####
# ERC20 Token
####

type Erc20Token @entity {
    "Token address"
    id: Bytes!

    _protocol: Protocol!

    "Token address"
    address: Bytes!
    "Token name"
    name: String!
    "Token symbol"
    symbol: String!
    "Token decimals"
    decimals: Int!

    "Current data"
    data: Erc20TokenData!
    lastUpdatedBlock: BigInt!
    lastDerivedPriceBlock: BigInt!

    # Derived
    erc20InputTokenFills: [Erc20Fill!]! @derivedFrom(field: "inputToken")
    erc20OutputTokenFills: [Erc20Fill!]! @derivedFrom(field: "outputToken")
    pairsA: [Erc20TokenPair!]! @derivedFrom(field: "tokenA")
    pairsB: [Erc20TokenPair!]! @derivedFrom(field: "tokenB")

    nftFills: [NftFill!]! @derivedFrom(field: "erc20Token")
}

type Erc20TokenData @entity {
    "TokenId + time qualifier"
    id: Bytes!

    token: Erc20Token!

    erc20FillInputVolume: BigInt!
    erc20FillOutputVolume: BigInt!

    erc20FillInputVolumeUsd: BigDecimal!
    erc20FillOutputVolumeUsd: BigDecimal!

    erc20InputFillCount: BigInt!
    erc20OutputFillCount: BigInt!

    nftFillVolume: BigInt!
    nftFillVolumeUsd: BigDecimal!
    nftFillCount: BigInt!

    derivedPriceInEth: BigDecimal!
    derivedPriceInUsd: BigDecimal!
}

type Erc20TokenPair @entity {
    "tokenA address + tokenB address, note that tokens A is the one with the lowest address to ensure two tokens only have 1 Erc20TokenPair"
    id: Bytes!

    _protocol: Protocol!

    "Token A in the pair"
    tokenA: Erc20Token!
    "Token B in the pair"
    tokenB: Erc20Token!

    "Current data"
    data: Erc20TokenPairData!
    lastUpdatedBlock: BigInt!

    # Derived
    fills: [Erc20Fill!]! @derivedFrom(field: "tokenPair")
}

type Erc20TokenPairData @entity {
    "pairId + time qualifier"
    id: Bytes!

    "Volume of tokenA traded to tokenB for the time period"
    volumeAtoB: BigInt!
    "Volume of tokenB traded to tokenA for the time period"
    volumeBtoA: BigInt!

    fillCountAtoB: BigInt!
    fillCountBtoA: BigInt!

    "Exchange rate (a.k.a price) from tokenA to tokenB, i.e tokenAAmount * 10^(tokenADecimals) * exchangeRateAtoB = tokenB equivalent"
    exchangeRateAtoB: BigDecimal!
    "Exchange rate (a.k.a price) from tokenB to tokenA, i.e tokenBAmount * 10^(tokenBDecimals) * exchangeRateBtoA = tokenA equivalent"
    exchangeRateBtoA: BigDecimal!
}

enum Erc20FillType {
    LimitOrder
    RfqOrder
    OtcOrder
    BridgeOrder
    PlugableLiquidityProvider
    OptimizedUniswapV2
    OptimizedSushiSwap
    OptimizedPancakeSwap
    OptimizedUniswapV3
}

type Erc20Fill @entity(immutable: true) {
    "txn hash + log index"
    id: Bytes!

    _protocol: Protocol!

    blockNumber: BigInt!
    timestamp: BigInt!

    transaction: Transaction!
    logIndex: BigInt!

    type: Erc20FillType!
    _fillTypeSummary: Erc20FillTypeSummary!

    "Account which is the source of input tokens, this is the maker for native order and the swapper for AMMs"
    source: Account!
    "Account which is filling the trade, this is the taker in native order, or the liquidity pool in AMMs"
    filler: Account!
    "Account which is receiving the output tokens from the filler, this is the maker in native orders"
    destination: Account!

    "Input token to the fill, this is the maker token for native orders"
    inputToken: Erc20Token!
    "Output token being filled, this is the taker token for native orders"
    outputToken: Erc20Token!

    "Amount of input tokens in the fill"
    inputTokenAmount: BigInt!
    "Amount of output tokens in the fill"
    outputTokenAmount: BigInt!

    # Optional fee payed with the fill
    feeRecipient: Account!
    "Fee recipient amount in output tokens"
    feeRecipientAmount: BigInt!
    "Protocol fee paid in output tokens"
    protocolFeeAmount: BigInt!

    "Optional extra data, this is used to store the order hash + pool for native orders, and pool info for bridge orders"
    extraData: String

    tokenPair: Erc20TokenPair!
}

type Erc20FillTypeSummary @entity(immutable: true) {
    id: Bytes!

    _protocol: Protocol!

    type: Erc20FillType!

    data: Erc20FillTypeSummaryData!

    # Derived
    erc20Fills: [Erc20Fill!]! @derivedFrom(field: "_fillTypeSummary")
}

type Erc20FillTypeSummaryData @entity {
    id: Bytes!

    fillVolumeUsd: BigDecimal!
    fillCount: BigInt!
    uniqueUsers: BigInt!
}

####
# NFT
####

enum NftCollectionType {
    Erc721
    Erc1155
}

type NftCollection @entity {
    "Address"
    id: Bytes!

    _protocol: Protocol!

    type: NftCollectionType!

    address: Bytes!

    # Some ERC721 don't support and ERC1155 doesn't support these
    name: String
    symbol: String

    data: NftCollectionData!

    # Derived
    nfts: [Nft!]! @derivedFrom(field: "collection")
    fills: [NftFill!]! @derivedFrom(field: "collection")
}

type NftCollectionData @entity {
    id: Bytes!

    fillCount: BigInt!
    erc20VolumeUsd: BigDecimal!
    averageFillPriceUsd: BigDecimal!
}

type Nft @entity {
    "Collection address + tokenId"
    id: Bytes!

    _protocol: Protocol!

    collection: NftCollection!

    tokenId: BigInt!
    tokenUri: String

    # Derived
    fills: [NftFill!]! @derivedFrom(field: "nft")
}

enum NftFillDirection {
    SELL
    BUY
}

type NftFill @entity {
    id: Bytes!

    _protocol: Protocol!

    blockNumber: BigInt!
    timestamp: BigInt!

    transaction: Transaction!
    logIndex: BigInt!

    type: NftCollectionType!
    direction: NftFillDirection!

    maker: Account!
    taker: Account!

    collection: NftCollection!
    nft: Nft!

    erc20Token: Erc20Token!
    erc20TokenAmount: BigInt!
}

####
# Transaction
####

type Transaction @entity {
    "Transaction hash"
    id: Bytes!

    _protocol: Protocol!

    "Transaction hash"
    hash: Bytes!
    "Block number this transaction is part of"
    blockNumber: BigInt!
    "Timestamp of this transaction in UTC"
    timestamp: BigInt!

    "Address the transaction is from"
    from: Bytes!
    "Address the transaction is to"
    to: Bytes

    "Gas limit for the transaction"
    gasLimit: BigInt!
    "Gas price for the transaction"
    gasPrice: BigInt!
    "Amount of gas used - optional since not all graph node versions support"
    gasUsed: BigInt

    # Counts for filtering
    erc20FillCount: Int!
    erc20TransferCount: Int!
    nftFillCount: Int!

    erc20Transfers: [Erc20Transfer!]!

    # Derived
    erc20Fills: [Erc20Fill!]! @derivedFrom(field: "transaction")
    nftFills: [NftFill!]! @derivedFrom(field: "transaction")
}

# Helper to derive sender and receiver where events are missing data, and also help reconstruct entire trades
type Erc20Transfer @entity(immutable: true) {
    "txn hash + log index"
    id: Bytes!

    transaction: Transaction!
    logIndex: BigInt!
    token: Erc20Token!

    from: Account!
    to: Account!
    amount: BigInt!
}

####
# Historical Snapshots
####
